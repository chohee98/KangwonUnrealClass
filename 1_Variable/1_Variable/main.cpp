#include <iostream>
#include <stdlib.h>

int main()
{
	//컴퓨터는 0, 1 표현할 수 있는 1개를 bit라고 한다.
	//2진법4개 bit일때는 0~15 16개 숫자를 표현
	//0000 0000=0
	//0000 0001=1
	//0000 0010=2
	//0000 0100=4
	//0000 1000=8
	//0001 0000=16
	//0010 0000=32
	//0100 0000=64
	//1000 0000=128
	//1111 1111=255
	//1000 0000: 맨 앞 부호가 1이면 (-), 0이면 (+)

	//0111 1111=127
	//0000 0001
	//1000 0000=-128
	//0000 0001(1) + 1111 1111(-1) = 0000 0000(0)
	//0110 0100(100) + 1001 1100(-100) = 0000 0000(0)

	signed char c; //-128~127 (1byte)
	unsigned char uc=200; //0~255 (1byte)
	c = 128;

	//short int = short : 작은 정수
	short s; //-32,768~32,767 (2byte) 0000 0000 0000 0000

	//long int = long : 큰 정수
	long I; //4byte

	//int 자료형
	//최초 16bit 아키텍처 일때는 16bit 이다.
	//32bit 아키텍처 일때는 32bit
	//64bit 아키텍처 일때는 32bit
	//int64 = 64bit

	int A = 214; //숫자, 음수, 양수, 정수
	unsigned int uA; //숫자, 양수, 정수

	float f = 0.1f; //4byte
	f = 2.0f;
	f = 2.f;

	//부동소수점
	//0001 0000 = 1이라면,
	//0000 1000 = 0.5
	//0000 0100 = 0.25
	//0000 0010 = 0.125
	//0000 0001 = 0.0625
	//0000 1101 = 0.5 + 0.25 + 0.0625 = 0.8125
	// 0(부호부) / 000 0000 0(지수부) / 000 0000 0000 0000 0000 0000 (가수부)
	//21.8125 = 21(10101).8125(0.1101)
	//21.8125->10101.1101 * 2^5 = 0.101011101->5승을 2진법으로 바꾸면 (101)
	//-> 0(부호부) / 000 0010 1(지수부) / 101 0111 0100 0000 0000 0000 (가수부)
	//명확하게 0.1을 표기하라고 한다면 0000 0001 1011 1001

	double d = 0.1; //8byte float 보다 더 정밀하다


	//int 1 = 0000 0001
	//float 1 = 0001 0001 100000
	int i2 = 0;
	float f2 = 1.0f;
	i2 = (int) f2;	//변수 타입 캐스팅

	//대입연산자(=)
	//오른쪽에 값을 왼쪽에 대입한다.

	//연산자
	//+, -, *, /, %, ++, --
	i2 = 1 + 1;
	i2 = i2 + 1;
	i2 += 1; //i2=i2+1;과 동일

	float divide = 10 / 2.0f; // 10 * 0.5f;
	float remain = 10 % 3; 
	//실수끼리는 나머지 연산 불가능 (몇번째 소수점 자리를 기준으로 연산을 해야하는지 알수 없음)
	//즉, 둘 다 정수 일때만 나머지 연산 가능

	int add = 0, minus = 10; //변수를 선언하면 초기화 값을 넣어준다.	
	minus--;
	--minus;

	int addR = 0, addL = 0;
	addL = ++add;	//전치 연산
	addR = add++;	//후치 연산은 대입연산자(=)보다 더 뒤에 실행

	//논리연산자
	//&&(AND), ||(OR), !(NOT)
	//And: 둘 다 참이면 참, 그렇지 않으면 거짓
	//OR: 둘 중에 하나라도 참이면 참, 그렇지 않으면 거짓
	//NOT: 참이면 거짓, 거짓이면 참
	//Yes: 0이 아닌 값, true(1)
	//No: 0이면, false(0)
	bool bResult = true; //true 대신 false, 1, 0 대입 가능

	bResult = 0 && 20;
	bResult = 0 || 20;
	bResult = !0;

	//주석: 컴파일에 포함되자 않는 문자
	//자주 쓰는 단축키
	//지정한 구문 주석: Ctrl+k -> Ctrl+c
	//지정한 구문 주석 해제: Ctrl+k -> Ctrl+u
	//alt drag: 부분 영역 지정

	//디버깅 단축키
	//f5: 디버깅 시작, 디버깅 계속 진행
	//f9: 중단점 생성 및 해제
	//f10: 디버깅 중 다음 구문 진행
	//f11: 디버깅 중 함수 내부 구문 진행
	//shift+f5: 디버깅 종료

	//비교 연산자
	//== : 같으면 true, 아니면 false
	//!= : 같으면 false, 아니면 true
	//> : 왼쪽이 오른쪽보다 크면 true, 아니면 false
	//>= : 왼쪽이 오른쪽보다 크거나 같으면 true, 아니면 false
	bResult = (10 == 11);
	bResult = (10 != 11);
	bResult = (10 > 11);
	bResult = (10 < 11);

	int nResult = (10 == 11) ? 100 : 50;

	//문제 아래 time 들어있는 초 값에 분과 시간을 구해라.
	unsigned int sesc = 987654321; //초
	unsigned int day = 0, hour = 0, min = 0, sec = 0;
	/*day = sesc / (60 * 60 * 24);
	hour = (sesc - day * (60 * 60 * 24)) / (60 * 60);
	min = (sesc - day * (60 * 60 * 24) - hour * (60*60)) / 60;
	sec = (sesc - day * (60 * 60 * 24) - hour * (60 * 60) - min * 60);*/

	sec = sesc % 60; //0~59
	min = (sesc / 60) % 60; //0~59
	hour = ((sesc / 60) / 60) % 24;
	day = ((sesc / 60) / 60) / 24;


	printf("%d일 ", day);
	printf("%d시간 ", hour);
	printf("%d분 ", min);
	printf("%d초\n", sec);

	//std::cout << A << std::endl;

	system("pause");
}